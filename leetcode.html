<!DOCTYPE html []>
<html>

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-167312978-2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'UA-167312978-2');
  </script>

  <meta charset="UTF-8" />
  <meta name="author" content="MarkdownViewer++" />
  <link rel="stylesheet" href="assets/css/main.css" />
  <title>leetcode.txt</title>
  <style type="text/css">
    /* Avoid page breaks inside the most common attributes, especially for exports (i.e. PDF) */
    td,
    h1,
    h2,
    h3,
    h4,
    h5,
    p,
    ul,
    ol,
    li {
      page-break-inside: avoid;
    }
  </style>
</head>

<body>
  <h1 id="arrays">Arrays</h1>
  <h2 id="two-sum">1. Two Sum</h2>
  <p>
    <strong>Description:</strong> See if two distinct elements in an integer array add up to a target sum.</p>
  <p>
    <strong>Naive:</strong> Do a double for-loop to check every possible pair of integers</p>
  <p>
    <strong>Smart:</strong> Store (value,index) in HashMap in first for-loop, check if map contains complement (and not
    same index) in second for-loop</p>
  <p>
    <strong>Intuition:</strong> Fast contains check using HashMap</p>
  <p>
    <strong>Usefulness:</strong> 9</p>
  <h2 id="best-time-to-buy-and-sell-stock">2. Best Time to Buy and Sell Stock</h2>
  <p>
    <strong>Description:</strong> Find largest positive difference between two array elements</p>
  <p>
    <strong>Naive:</strong> Loop through every subsequent number n for-loop to find largest difference</p>
  <p>
    <strong>Smart:</strong> Keep track of the current min, update max if curr - min &gt; max</p>
  <p>
    <strong>Intuition:</strong> Logic</p>
  <p>
    <strong>Usefulness:</strong> 8</p>
  <h2 id="contains-duplicate">3. Contains Duplicate</h2>
  <p>
    <strong>Description:</strong> Check if array contains duplicate</p>
  <p>
    <strong>Naive:</strong> Double for-loop to check for duplicates</p>
  <p>
    <strong>Smart:</strong> Sort first, then only look at adjacent elements</p>
  <p>
    <strong>Smarter:</strong> Add all to HashSet (which inserts in constant time due to hash structure), check if set
    size == old size since sets do not contain duplicates</p>
  <p>
    <strong>Intuition:</strong> Fast search using sort, or use set's definition</p>
  <p>
    <strong>Usefulness:</strong> 9</p>
  <h2 id="product-of-array-except-self">4. Product of Array Except Self</h2>
  <p>
    <strong>Description:</strong> Find product of all other elements except for self in an integer array (for every
    element). <strong>Note:</strong> No division allowed, O(n) required.</p>
  <p>
    <strong>Naive:</strong> For every element, calculate products before and after it and multiply them. However, O(n^2)
    so no.</p>
  <p>
    <strong>Smart:</strong> Calculate product before every element and after every element through building array from
    both sides, get answer array by multiplying at every index.</p>
  <p>
    <strong>Intuition:</strong> Most of the product is reused for every loop, can use building array (* last element) to
    simplify calculations.</p>
  <p>
    <strong>Usefulness:</strong> 10</p>
  <h2 id="maximum-subarray">5. Maximum Subarray</h2>
  <p>
    <strong>Description:</strong> Find the subarray which has the largest subarray sum</p>
  <p>
    <strong>Naive:</strong> Iterate through every possible subarray, find sum and check max</p>
  <p>
    <strong>Smart:</strong> The max sum at the current index is either</p>
  <ol>
    <li>The previous sum containing nums[i-1] + the current number nums[i]</li>
    <li>The previous max subarray sum</li>
  </ol>
  <p>Keep track of two variables: sum containing current element, running max</p>
  <p>
    <strong>Intuition:</strong> One of the confusing parts of this is how the current sum (containing current element)
    is updated correctly. Imagine if you had 4, -1, -12. The current sum would be 4 at first, then it will turn into 3
    when you hit -1 because 3 is better than the alternative, which is starting over with -1 as the only sum. When we
    reach -12, the current sum continue and become 3-12=-9 because -9 is better than going down all the way to -12.
    Although the sum continues to change, the max sum is continuously updated through the second variable to ensure that
    there is a global max stored. See Kadane's Algorithms for more.</p>
  <p>
    <strong>Usefulness:</strong> 10</p>
  <h2 id="maximum-product-subarray">6. Maximum Product Subarray</h2>
  <p>
    <strong>Description:</strong> Find largest continuous product in array</p>
  <p>
    <strong>Naive:</strong> Double for-loop</p>
  <p>
    <strong>Smart:</strong> Keep track of current minimum and maximum (that ends on the current array index). For every
    array element, calculate the 2 possible products <code>nums[i] * min</code> and <code>nums[i] * max</code>. Assign
    the smallest of these two products and <code>nums[i]</code> itself to min, and assign the largest of these three
    numbers to max. Then, keep track of the global max by comparing global max with the current max (that ends with the
    current array index).</p>
  <p>
    <strong>Intuition:</strong> Since negative numbers can occur, we have to make sure we also keep track of the
    smallest number (most negative) in case another negative number comes along and flips that to the largest. Similar
    to #5, but using two "ends-here" extremes (min/max) to account for negative products.</p>
  <p>
    <strong>Usefulness:</strong> 9</p>
  <h2 id="find-minimum-in-rotated-sorted-array">7. Find Minimum in Rotated Sorted Array</h2>
  <p>
    <strong>Description:</strong> Find the minimum number when a sorted array has been rotated</p>
  <p>
    <strong>Naive:</strong> Scan until <code>nums[i]&gt;nums[i+1]</code>: O(N)</p>
  <p>
    <strong>Smart:</strong> Binary Search with decision:</p>
  <ol>
    <li>Move high if mid &gt; high (something is wrong in the 2nd half)</li>
    <li>Move low if mid &lt; high (top is fine, check low)</li>
  </ol>
  <p>
    <strong>Intuition:</strong> Normal linear scan is fine at O(N), but binary search with the special if-condition
    allows a much faster scan using the property of this rotated sorted array.</p>
  <p>
    <strong>Usefulness:</strong> 10</p>
  <h2 id="search-in-rotated-sorted-array">8. Search in Rotated Sorted Array</h2>
  <p>
    <strong>Description:</strong> Find the target number in a rotated sorted array, return -1 if not found.</p>
  <p>
    <strong>Naive:</strong> Linear search to not deal with rotated property</p>
  <p>
    <strong>Smart:</strong> Find the minimum index, select which side of the array to perform binary search on, perform
    normal binary search on sorted subarray.</p>
  <p>
    <strong>Intuition:</strong> Building on from #7, we can separate the array into two subarrays if we can first find
    the minimum index through the O(log(N)) operation from #7. Then, we can separate the array into two sorted
    subarrays. Based on which side the array is in (by comparing with last element), we can easily use binary search on
    that subarray.</p>
  <p>
    <strong>Usefulness:</strong> 9</p>
  <p>
    <strong>Usefulness:</strong> 10</p>
  <h2 id="sum">9. 3Sum</h2>
  <p>
    <strong>Description:</strong> Find all triples in array that sums to 0.</p>
  <p>
    <strong>Naive:</strong> Triple for-loop</p>
  <p>
    <strong>Smart:</strong> Sort array first, do a 2Sum (O(N)) for each array entry.</p>
  <p>
    <strong>Intuition:</strong> Since we have to find all triples, we can start with the naive implementation with the
    triple for-loop. Since we know that we can use a front-back search to simplify 2Sum to O(N) rather than O(N^2), we
    can simplify the original O(N^3) solution down to O(N^2). We also used HashSet to eliminate potential duplicates.
  </p>
  <p>
    <strong>Usefulness:</strong> 10</p>
  <h2 id="container-with-most-water">10. Container with Most Water</h2>
  <p>
    <strong>Description:</strong> Find largest size in array where width=length between indices and height=minimum of
    two heights.</p>
  <p>
    <strong>Naive:</strong> Double for-loop</p>
  <p>
    <strong>Smart:</strong> Two pointer from both ends. If left end is shorter than right, increase left pointer by one
    because if you move the longer one (right one) inward, any possible size will be less than the current size because
    they are all either limited by the left's height, or even shorter than that on the right. Same logic for moving the
    right inward</p>
  <p>
    <strong>Intuition:</strong> To reduce it from a double for-loop to a faster algorithm, we have to think about what
    cases are redundant. Since the smaller height will always be limiting, we can just increment it and skip all of its
    other combinations. This results in a O(N) time complexity because the program stops running when the pointers
    crosses.</p>
  <p>
    <strong>Usefulness:</strong> 10</p>
  <h1 id="dynamic-programming">Dynamic Programming</h1>
</body>

</html>